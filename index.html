<!doctype html>
<html lang="es-AR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#590404" />
  <title>El impostor</title>
  <link rel="stylesheet" href="styles.css" />
  <link rel="icon" href="logo_blanco.svg" id="favicon" />
</head>

<body>
  <div class="app">
    <div class="topbar">
      <div class="brand">
        <img class="mascot" src="logo_blanco.svg" alt="Logo de El impostor" id="brandLogo" />
        <div>
          <h1>El impostor</h1>
        </div>
      </div>
      <div class="topbar-actions">
        <button class="theme-toggle" id="themeToggle" type="button" aria-pressed="false">Modo oscuro</button>
        <div class="pill" id="dbPill">Cartas: <strong id="dbCount">‚Ä¶</strong></div>
      </div>
    </div>


    <div class="steps" id="steps" aria-label="Progreso de la partida">
      <div class="step active" data-step="setup"><span class="dot"></span><span class="txt">Config</span></div>
      <div class="step" data-step="pass"><span class="dot"></span><span class="txt">Pasar</span></div>
      <div class="step" data-step="reveal"><span class="dot"></span><span class="txt">Ver</span></div>
      <div class="step" data-step="play"><span class="dot"></span><span class="txt">Jugar</span></div>
      <div class="step" data-step="summary"><span class="dot"></span><span class="txt">Resumen</span></div>
    </div>

    <!-- SETUP -->
    <section class="card screen active" id="screenSetup">
      <h2 class="title">Configurar partida</h2>
      <p class="desc">
        Eleg√≠ impostores, carg√° nombres y empez√°. El impostor ve una pista, los dem√°s ven la palabra.
      </p>

      <label>¬øCu√°ntos impostores?</label>
      <div class="seg" role="group" aria-label="Cantidad de impostores">
        <button type="button" class="segBtn" data-impostors="1" aria-pressed="true">1 impostor</button>
        <button type="button" class="segBtn" data-impostors="2" aria-pressed="false">2 impostores</button>
      </div>

      <label>Nombres</label>
      <div class="namesGrid" id="namesGrid" aria-label="Lista de jugadores">
        <input class="nameInput" type="text" inputmode="text" autocomplete="off" placeholder="Jugador 1" data-index="0" />
        <input class="nameInput" type="text" inputmode="text" autocomplete="off" placeholder="Jugador 2" data-index="1" />
        <input class="nameInput" type="text" inputmode="text" autocomplete="off" placeholder="Jugador 3" data-index="2" />
      </div>
      <p class="tiny hint" id="namesHint">Se agregan m√°s campos autom√°ticamente hasta 10 jugadores.</p>

      <div class="chipset" id="namesChips" aria-label="Lista de jugadores"></div>

      <label>Categor√≠as de palabras</label>
      <div class="metaRow">
        <button class="btn secondary" id="btnCategories" type="button">Seleccionar categor√≠as</button>
        <div class="pill mini" id="categoryPill">Categor√≠as: <strong id="categoryCount">‚Äî</strong></div>
      </div>
      <p class="tiny" id="categorySummary">Todas las categor√≠as activas.</p>

      <div class="spacer"></div>

      <div class="metaRow" aria-label="Estado">
        <div class="pill mini" id="savedPill">Nombres: <strong id="savedState">‚Äî</strong></div>
        <div class="pill mini">M√≠nimo: <strong id="minPlayers">‚Äî</strong></div>
      </div>

      <div class="footerRow">
        <button class="btn" id="btnStart" type="button" disabled>Iniciar juego</button>
        <button class="btn secondary" id="btnClearNames" type="button">Borrar nombres</button>
      </div>

      <p class="tiny">
        Tip: cuando toc√°s <b>Estoy listo</b>, aparece tu palabra o tu pista. Mir√° r√°pido y pas√°.
      </p>
    </section>

    <!-- PASS -->
    <section class="card screen" id="screenPass">
      <div style="display:flex; justify-content:space-between; gap:10px; align-items:center; position:relative; z-index:1;">
        <div class="pill">Jugador <strong id="passIdx">1</strong>/<strong id="passTotal">1</strong></div>
        <button class="btn secondary" id="btnAbort" type="button" style="width:auto; padding:10px 12px;">Volver</button>
      </div>

      <div class="center" style="position:relative; z-index:1;">
        <img class="passMascot" src="logo_blanco.svg" alt="Logo de El impostor" id="passLogo" />
        <div class="big">Pas√° el celu a</div>
        <div class="secret" id="passName">‚Äî</div>
        <p class="desc">Cuando lo tengas, toc√° el bot√≥n para ver tu rol.</p>
        <div class="spacer"></div>
        <button class="btn" id="btnImReady" type="button">Estoy listo</button>
        <p class="tiny">Que nadie mire üòÑ</p>
      </div>
    </section>

    <!-- REVEAL -->
    <section class="card screen" id="screenReveal">
      <div style="display:flex; justify-content:space-between; gap:10px; align-items:center; position:relative; z-index:1;">
        <div class="pill">Turno de <strong id="revealName">‚Äî</strong></div>
      </div>

      <div class="revealBox">
        <div class="badge warn" id="roleBadge">Rol</div>

        <div id="secretWrap" aria-live="polite">
          <div class="secret" id="secretMain">‚Äî</div>
          <p class="secretSub" id="secretSub">‚Äî</p>
        </div>

        <p class="tiny" style="margin-top:10px;">
          Cuando termines, toc√° <b>Ocultar y pasar</b>.
        </p>

        <div class="footerRow">
          <button class="btn secondary" id="btnHideNext" type="button">Ocultar y pasar</button>
        </div>
      </div>
    </section>

    <!-- PLAY -->
    <section class="card screen" id="screenPlay">
      <h2 class="title">¬°A jugar!</h2>
      <p class="desc">
        Ya todos vieron su rol. Ahora juegan y cuando quieran, finalizan la partida.
      </p>

      <div class="revealBox">
        <div class="badge good">Partida en curso</div>
        <p class="desc" style="margin-top:4px;">
          Impostores: <b id="playImpostors">1</b> ¬∑ Jugadores: <b id="playPlayers">‚Äî</b>
        </p>

        <div class="footerRow">
          <button class="btn danger" id="btnFinish" type="button">Finalizar partida</button>
          <button class="btn secondary" id="btnNew" type="button">Repartir de nuevo</button>
        </div>
      </div>
    </section>

    <!-- SUMMARY -->
    <section class="card screen" id="screenSummary">
      <h2 class="title">Resumen</h2>
      <p class="desc">Palabra real y qui√©n(es) fueron impostor(es).</p>

      <div class="revealBox">
        <div class="secret" id="sumWord">‚Äî</div>
        <p class="secretSub" id="sumClue">‚Äî</p>

        <div class="spacer"></div>
        <div class="badge bad">Impostor(es)</div>
        <div id="sumImpostors" class="chipset"></div>

        <div class="spacer"></div>
        <div class="badge good">No impostores</div>
        <div id="sumCrew" class="chipset"></div>

        <div class="footerRow">
          <button class="btn" id="btnBackSetup" type="button">Volver al inicio</button>
        </div>
      </div>
    </section>
  </div>

  <dialog id="categoryDialog" class="categoryDialog" aria-labelledby="categoryTitle">
    <form method="dialog" class="dialogCard">
      <div class="dialogHeader">
        <h3 id="categoryTitle">Categor√≠as de la ronda</h3>
        <button type="button" class="iconBtn" id="btnCloseCategories" aria-label="Cerrar">√ó</button>
      </div>
      <p class="desc">Eleg√≠ las categor√≠as con las que van a jugar para que todos entiendan la tem√°tica.</p>
      <div class="dialogActions">
        <button type="button" class="btn secondary small" id="btnCatAll">Seleccionar todas</button>
        <button type="button" class="btn secondary small" id="btnCatNone">Deseleccionar todas</button>
      </div>
      <div class="categoryList" id="categoryList"></div>
      <div class="footerRow">
        <button class="btn" id="btnSaveCategories" type="button">Guardar categor√≠as</button>
      </div>
    </form>
  </dialog>

  <script>
    // Helpers
    const $ = (sel) => document.querySelector(sel);

    const screens = {
      setup: $("#screenSetup"),
      pass: $("#screenPass"),
      reveal: $("#screenReveal"),
      play: $("#screenPlay"),
      summary: $("#screenSummary"),
    };
    function updateSteps(activeKey){
      const stepsEl = $("#steps");
      if(!stepsEl) return;
      const order = ["setup","pass","reveal","play","summary"];
      const activeIdx = order.indexOf(activeKey);

      stepsEl.querySelectorAll(".step").forEach((el) => {
        const k = el.dataset.step;
        const idx = order.indexOf(k);
        el.classList.toggle("active", k === activeKey);
        el.classList.toggle("done", idx > -1 && activeIdx > -1 && idx < activeIdx);
      });
    }

    function focusForScreen(key){
      const map = {
        setup: () => $("#namesInput"),
        pass: () => $("#btnImReady"),
        reveal: () => $("#btnHideNext"),
        play: () => $("#btnFinish"),
        summary: () => $("#btnBackSetup"),
      };
      try{
        const el = map[key]?.();
        if(el) requestAnimationFrame(() => el.focus({ preventScroll: true }));
      }catch(e){}
    }

    let currentScreen = "setup";

    function showScreen(key){
      if(!screens[key]) return;
      const prevKey = currentScreen;
      if(prevKey && prevKey !== key && screens[prevKey]){
        const prevEl = screens[prevKey];
        prevEl.classList.remove("active");
        prevEl.classList.add("leaving");
        prevEl.addEventListener("animationend", () => {
          prevEl.classList.remove("leaving");
        }, { once: true });
      }
      screens[key].classList.remove("leaving");
      screens[key].classList.add("active");
      currentScreen = key;
      updateSteps(key);
      window.scrollTo({ top: 0, behavior: "smooth" });
      focusForScreen(key);
    }
    function vibrate(ms=18){
      try{ if (navigator.vibrate) navigator.vibrate(ms); }catch(e){}
    }
    function shuffle(arr){
      const a = arr.slice();
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }
    function sampleOne(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

    // LocalStorage (nombres y configuraci√≥n)
    const LS = {
      names: "impostor_ar_names_v1",
      impostors: "impostor_ar_impostors_v1",
      theme: "impostor_ar_theme_v1",
      categories: "impostor_ar_categories_v1",
    };
    function storageGet(key){
      try{ return localStorage.getItem(key); }catch(e){ return null; }
    }
    function storageSet(key, val){
      try{ localStorage.setItem(key, String(val)); }catch(e){}
    }
    function storageRemove(key){
      try{ localStorage.removeItem(key); }catch(e){}
    }
    function storageGetJSON(key, fallback = null){
      const raw = storageGet(key);
      if(!raw) return fallback;
      try{ return JSON.parse(raw); }catch(e){ return fallback; }
    }
    function storageSetJSON(key, val){
      storageSet(key, JSON.stringify(val));
    }


    // State
    let wordsDB = [];
    let fullWordsDB = [];
    let categories = [];
    let selectedCategories = new Set();
    let draftCategories = new Set();
    let impostorsCount = 1;

    let players = [];
    let impostorIdx = [];
    let currentPlayer = 0;

    let round = { palabra: "", pista: "", categoria: "" };

    const categoryLabels = {
      objetos: "Objetos",
      personas: "Personas",
      naturaleza: "Naturaleza",
      animales: "Animales",
      tecnologia: "Tecnolog√≠a",
      lugares: "Lugares",
      comida: "Comida",
      acciones: "Acciones",
    };

    function getCategoryLabel(category){
      if(categoryLabels[category]) return categoryLabels[category];
      return category
        .replace(/_/g, " ")
        .replace(/\b\w/g, (letter) => letter.toUpperCase());
    }

    // Elements
    const dbCount = $("#dbCount");
    const themeToggle = $("#themeToggle");
    const brandLogo = $("#brandLogo");
    const passLogo = $("#passLogo");
    const favicon = $("#favicon");

    const segBtns = Array.from(document.querySelectorAll(".segBtn"));
    const namesGrid = $("#namesGrid");
    const namesChips = $("#namesChips");
    const btnStart = $("#btnStart");
    const btnClearNames = $("#btnClearNames");
    const minPlayersEl = $("#minPlayers");
    const savedStateEl = $("#savedState");
    const savedPill = $("#savedPill");
    const btnCategories = $("#btnCategories");
    const categoryCount = $("#categoryCount");
    const categoryPill = $("#categoryPill");
    const categorySummary = $("#categorySummary");
    const categoryDialog = $("#categoryDialog");
    const categoryList = $("#categoryList");
    const btnSaveCategories = $("#btnSaveCategories");
    const btnCatAll = $("#btnCatAll");
    const btnCatNone = $("#btnCatNone");
    const btnCloseCategories = $("#btnCloseCategories");

    const passIdx = $("#passIdx");
    const passTotal = $("#passTotal");
    const passName = $("#passName");
    const btnImReady = $("#btnImReady");
    const btnAbort = $("#btnAbort");

    const revealName = $("#revealName");
    const roleBadge = $("#roleBadge");
    const secretMain = $("#secretMain");
    const secretSub = $("#secretSub");
    const secretWrap = $("#secretWrap");
    const btnHideNext = $("#btnHideNext");

    const playImpostors = $("#playImpostors");
    const playPlayers = $("#playPlayers");
    const btnFinish = $("#btnFinish");
    const btnNew = $("#btnNew");

    const sumWord = $("#sumWord");
    const sumClue = $("#sumClue");
    const sumImpostors = $("#sumImpostors");
    const sumCrew = $("#sumCrew");
    const btnBackSetup = $("#btnBackSetup");

    function applyTheme(theme){
      const root = document.documentElement;
      const useDark = theme === "dark";
      root.dataset.theme = useDark ? "dark" : "light";
      const logoSrc = useDark ? "logo_negro.svg" : "logo_blanco.svg";
      if(brandLogo) brandLogo.src = logoSrc;
      if(passLogo) passLogo.src = logoSrc;
      if(favicon) favicon.href = logoSrc;
      if(themeToggle){
        themeToggle.textContent = useDark ? "Modo claro" : "Modo oscuro";
        themeToggle.setAttribute("aria-pressed", useDark ? "true" : "false");
      }
    }

    function loadThemeFromStorage(){
      const savedTheme = storageGet(LS.theme);
      const theme = savedTheme === "dark" ? "dark" : "light";
      applyTheme(theme);
    }

    // Load JSON (siempre en mismo directorio)
    async function loadJSONOrDie(){
      const res = await fetch("./impostor_500.json", { cache: "no-store" });
      if(!res.ok) throw new Error("No se pudo cargar el mazo.");
      const data = await res.json();
      validateDB(data);
      setDB(data);
    }

    function validateDB(data){
      if(!Array.isArray(data)) throw new Error("Mazo inv√°lido.");
      if(data.length < 50) throw new Error("Mazo inv√°lido.");
      const x = data[0];
      if(!x || typeof x !== "object") throw new Error("Mazo inv√°lido.");
      if(!("palabra" in x) || !("pista" in x) || !("categoria" in x)) throw new Error("Mazo inv√°lido.");
    }

    function setDB(data){
      fullWordsDB = data
        .filter(x => x && typeof x.palabra === "string" && typeof x.pista === "string" && typeof x.categoria === "string")
        .map(x => ({
          palabra: x.palabra.trim(),
          pista: x.pista.trim(),
          categoria: x.categoria.trim(),
        }))
        .filter(x => x.palabra.length && x.pista.length && x.categoria.length);

      categories = Array.from(new Set(fullWordsDB.map(x => x.categoria)))
        .sort((a, b) => getCategoryLabel(a).localeCompare(getCategoryLabel(b), "es"));
      loadCategoriesFromStorage();
      applyCategoryFilter();
    }

    // Players
    function parseNames(list){
      const raw = list.map((value) => value.trim()).filter(Boolean);
      const seen = new Set();
      const unique = [];
      for(const n of raw){
        const key = n.toLowerCase();
        if(!seen.has(key)){
          seen.add(key);
          unique.push(n);
        }
      }
      return unique;
    }


    function getNameValues(){
      if(!namesGrid) return [];
      return Array.from(namesGrid.querySelectorAll(".nameInput")).map((input) => input.value);
    }

    function normalizedNames(){
      return parseNames(getNameValues()).join("\n");
    }

    function ensureNameInputs(){
      if(!namesGrid) return;
      const inputs = Array.from(namesGrid.querySelectorAll(".nameInput"));
      const maxPlayers = 10;
      const filledCount = inputs.filter((input) => input.value.trim().length > 0).length;
      const desiredCount = Math.min(maxPlayers, Math.max(3, Math.min(maxPlayers, filledCount + 1)));

      if(inputs.length < desiredCount){
        for(let i = inputs.length; i < desiredCount; i++){
          const input = document.createElement("input");
          input.className = "nameInput";
          input.type = "text";
          input.inputMode = "text";
          input.autocomplete = "off";
          input.placeholder = `Jugador ${i + 1}`;
          input.dataset.index = String(i);
          input.addEventListener("input", handleNamesInput);
          input.addEventListener("blur", handleNamesBlur);
          namesGrid.appendChild(input);
        }
      }

      if(inputs.length > desiredCount){
        for(let i = inputs.length - 1; i >= desiredCount; i--){
          namesGrid.removeChild(inputs[i]);
        }
      }
    }

    function renderInputsFromSaved(text){
      if(!namesGrid) return;
      const values = text.split(/\r?\n/).map((value) => value.trim()).filter(Boolean);
      const maxPlayers = 10;
      const count = Math.min(maxPlayers, Math.max(3, values.length + 1));
      namesGrid.innerHTML = "";
      for(let i = 0; i < count; i++){
        const input = document.createElement("input");
        input.className = "nameInput";
        input.type = "text";
        input.inputMode = "text";
        input.autocomplete = "off";
        input.placeholder = `Jugador ${i + 1}`;
        input.dataset.index = String(i);
        input.value = values[i] || "";
        input.addEventListener("input", handleNamesInput);
        input.addEventListener("blur", handleNamesBlur);
        namesGrid.appendChild(input);
      }
    }

    function updateSavedUI(){
      const saved = storageGet(LS.names) || "";
      const current = normalizedNames();
      let label = "No guardados";
      if(saved){
        label = (saved === current) ? "Guardados" : "Editados";
      }
      if(savedStateEl) savedStateEl.textContent = label;
      if(savedPill) savedPill.classList.toggle("dirty", saved && saved !== current);
    }

    function saveSetupToStorage(){
      storageSet(LS.impostors, impostorsCount);
      storageSet(LS.names, normalizedNames());
      updateSavedUI();
    }

    function loadSetupFromStorage(){
      const savedNames = storageGet(LS.names);
      if(savedNames && typeof savedNames === "string"){
        renderInputsFromSaved(savedNames);
      }else{
        renderInputsFromSaved("");
      }
      const savedImp = Number(storageGet(LS.impostors));
      if(savedImp === 1 || savedImp === 2){
        impostorsCount = savedImp;
      }
      segBtns.forEach(b => {
        const n = Number(b.dataset.impostors);
        b.setAttribute("aria-pressed", n === impostorsCount ? "true" : "false");
      });
      updateSavedUI();
    }

    function loadCategoriesFromStorage(){
      const saved = storageGetJSON(LS.categories, []);
      if(Array.isArray(saved)){
        selectedCategories = new Set(saved.filter((cat) => categories.includes(cat)));
      }
      if(selectedCategories.size === 0){
        selectedCategories = new Set(categories);
      }
    }

    function saveCategoriesToStorage(){
      storageSetJSON(LS.categories, Array.from(selectedCategories));
    }

    function updateCategorySummary(){
      const total = categories.length;
      const selected = selectedCategories.size;
      if(categoryCount) categoryCount.textContent = `${selected}/${total}`;
      if(categoryPill) categoryPill.classList.toggle("dirty", selected === 0);
      if(!categorySummary) return;
      if(selected === 0){
        categorySummary.textContent = "Seleccion√° al menos una categor√≠a.";
        return;
      }
      if(selected === total){
        categorySummary.textContent = "Todas las categor√≠as activas.";
        return;
      }
      const list = categories
        .filter((category) => selectedCategories.has(category))
        .map(getCategoryLabel)
        .slice(0, 3);
      const extra = selected - list.length;
      const suffix = extra > 0 ? ` y ${extra} m√°s` : "";
      categorySummary.textContent = `Activas: ${list.join(", ")}${suffix}.`;
    }

    function applyCategoryFilter(){
      wordsDB = fullWordsDB.filter((w) => selectedCategories.has(w.categoria));
      dbCount.textContent = wordsDB.length.toString();
      $("#dbPill").style.borderColor = "rgba(27,122,100,.30)";
      $("#dbPill").style.background = "rgba(27,122,100,.10)";
      updateCategorySummary();
    }

    function renderCategoryDialog(){
      if(!categoryList) return;
      categoryList.innerHTML = "";
      categories.forEach((cat) => {
        const row = document.createElement("label");
        row.className = "categoryItem";
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.value = cat;
        checkbox.checked = draftCategories.has(cat);
        checkbox.addEventListener("change", () => {
          if(checkbox.checked) draftCategories.add(cat);
          else draftCategories.delete(cat);
        });
        const span = document.createElement("span");
        span.textContent = getCategoryLabel(cat);
        row.appendChild(checkbox);
        row.appendChild(span);
        categoryList.appendChild(row);
      });
    }

    function openCategoryDialog(){
      draftCategories = new Set(selectedCategories);
      renderCategoryDialog();
      if(categoryDialog?.showModal){
        categoryDialog.showModal();
      }else if(categoryDialog){
        categoryDialog.setAttribute("open", "true");
      }
    }

    function closeCategoryDialog(){
      if(categoryDialog?.close){
        categoryDialog.close();
      }else if(categoryDialog){
        categoryDialog.removeAttribute("open");
      }
    }

    function toggleAllCategories(checked){
      draftCategories = checked ? new Set(categories) : new Set();
      renderCategoryDialog();
    }

    function refreshChips(){
      ensureNameInputs();
      players = parseNames(getNameValues());
      namesChips.innerHTML = "";

      players.forEach((name, idx) => {
        const chip = document.createElement("div");
        chip.className = "chip";
        chip.innerHTML = `<span>${name}</span>`;
        const x = document.createElement("button");
        x.type = "button";
        x.textContent = "√ó";
        x.title = "Quitar";
        x.addEventListener("click", () => {
          chip.classList.add("removing");
          vibrate(12);
          window.setTimeout(() => {
            const arr = parseNames(getNameValues());
            arr.splice(idx, 1);
            renderInputsFromSaved(arr.join("\n"));
            ensureNameInputs();
            refreshChips();
          }, 180);
        });
        chip.appendChild(x);
        namesChips.appendChild(chip);
      });

      const minPlayers = Math.max(3, impostorsCount + 2);
      btnStart.disabled = !(wordsDB.length > 0 && selectedCategories.size > 0 && players.length >= minPlayers);
      if(minPlayersEl) minPlayersEl.textContent = String(minPlayers);
      updateSavedUI();
    }

    // Round setup
    function setupNewRound(){
      if(!wordsDB.length) return;

      const pick = sampleOne(wordsDB);
      round.palabra = pick.palabra;
      round.pista = pick.pista;
      round.categoria = pick.categoria;

      const idx = shuffle([...players.keys()]);
      impostorIdx = idx.slice(0, impostorsCount).sort((a,b)=>a-b);

      currentPlayer = 0;

      passTotal.textContent = players.length;
      updatePass();
    }

    function updatePass(){
      passIdx.textContent = (currentPlayer + 1);
      passName.textContent = players[currentPlayer] ?? "‚Äî";
    }

    function isImpostor(i){ return impostorIdx.includes(i); }

    // Reveal (directo: palabra o pista)
    function openReveal(){
      const name = players[currentPlayer];
      revealName.textContent = name;

      const imp = isImpostor(currentPlayer);

      if(imp){
        roleBadge.className = "badge bad";
        roleBadge.textContent = "SOS IMPOSTOR üòà";
        secretMain.textContent = round.pista;
        secretSub.textContent = `Categor√≠a: ${getCategoryLabel(round.categoria)} ¬∑ ${round.palabra.length} letras. Disimul√° y trat√° de adivinar la palabra.`;
      }else{
        roleBadge.className = "badge good";
        roleBadge.textContent = "NO SOS IMPOSTOR ‚úÖ";
        secretMain.textContent = round.palabra;
        secretSub.textContent = "Guardate la palabra y disimul√°.";
      }

      if(secretWrap){
        secretWrap.classList.remove("animate");
        void secretWrap.offsetWidth;
        secretWrap.classList.add("animate");
      }
      vibrate(14);
      showScreen("reveal");
    }

    function nextPlayerOrPlay(){
      currentPlayer++;
      if(currentPlayer >= players.length){
        playImpostors.textContent = String(impostorsCount);
        playPlayers.textContent = String(players.length);
        vibrate(20);
        showScreen("play");
      }else{
        updatePass();
        showScreen("pass");
      }
    }

    // Summary
    function renderSummary(){
      sumWord.textContent = round.palabra;
      sumClue.textContent = `Pista: ${round.pista} ¬∑ Categor√≠a: ${getCategoryLabel(round.categoria)}`;

      sumImpostors.innerHTML = "";
      sumCrew.innerHTML = "";

      const impSet = new Set(impostorIdx);
      players.forEach((p, i) => {
        const chip = document.createElement("div");
        chip.className = "chip";
        chip.innerHTML = `<span>${p}</span>`;
        if(impSet.has(i)) sumImpostors.appendChild(chip);
        else sumCrew.appendChild(chip);
      });
    }

    // Events
    segBtns.forEach(btn => {
      btn.addEventListener("click", () => {
        impostorsCount = Number(btn.dataset.impostors);
        segBtns.forEach(b => b.setAttribute("aria-pressed", b === btn ? "true" : "false"));
        refreshChips();
        storageSet(LS.impostors, impostorsCount);
        updateSavedUI();
        vibrate(12);
      });
    });

    function handleNamesInput(){
      ensureNameInputs();
      refreshChips();
    }

    function handleNamesBlur(){
      ensureNameInputs();
      refreshChips();
    }

    if(namesGrid){
      namesGrid.addEventListener("input", (event) => {
        if(event.target && event.target.classList.contains("nameInput")){
          handleNamesInput();
        }
      });
      namesGrid.addEventListener("blur", (event) => {
        if(event.target && event.target.classList.contains("nameInput")){
          handleNamesBlur();
        }
      }, true);
    }
    if(btnCategories){
      btnCategories.addEventListener("click", openCategoryDialog);
    }
    if(btnCloseCategories){
      btnCloseCategories.addEventListener("click", () => {
        closeCategoryDialog();
        vibrate(10);
      });
    }
    if(btnCatAll){
      btnCatAll.addEventListener("click", () => {
        toggleAllCategories(true);
        vibrate(10);
      });
    }
    if(btnCatNone){
      btnCatNone.addEventListener("click", () => {
        toggleAllCategories(false);
        vibrate(10);
      });
    }
    if(btnSaveCategories){
      btnSaveCategories.addEventListener("click", () => {
        selectedCategories = new Set(draftCategories);
        saveCategoriesToStorage();
        applyCategoryFilter();
        refreshChips();
        closeCategoryDialog();
        vibrate(12);
      });
    }

    if(themeToggle){
      themeToggle.addEventListener("click", () => {
        const nextTheme = document.documentElement.dataset.theme === "dark" ? "light" : "dark";
        applyTheme(nextTheme);
        storageSet(LS.theme, nextTheme);
        vibrate(12);
      });
    }


    if(btnClearNames) btnClearNames.addEventListener("click", () => {
      const hasSaved = !!(storageGet(LS.names) || "").trim();
      const hasCurrent = getNameValues().some((value) => value.trim().length > 0);
      if(!hasSaved && !hasCurrent){
        vibrate(10);
        return;
      }
      const ok = confirm("¬øBorrar los nombres guardados y limpiar la lista?");
      if(!ok) return;

      storageRemove(LS.names);
      renderInputsFromSaved("");
      refreshChips();
      vibrate(18);
    });


    btnStart.addEventListener("click", () => {
      refreshChips();
      saveSetupToStorage();
      setupNewRound();
      showScreen("pass");
    });

    btnAbort.addEventListener("click", () => {
      showScreen("setup");
      vibrate(16);
    });

    btnImReady.addEventListener("click", openReveal);
    btnHideNext.addEventListener("click", nextPlayerOrPlay);

    // Finalizar partida sin confirmaci√≥n
    btnFinish.addEventListener("click", () => {
      renderSummary();
      showScreen("summary");
      vibrate(24);
    });

    btnNew.addEventListener("click", () => {
      refreshChips();
      if(btnStart.disabled){
        showScreen("setup");
        vibrate(12);
        return;
      }
      setupNewRound();
      showScreen("pass");
      vibrate(16);
    });

    btnBackSetup.addEventListener("click", () => {
      refreshChips();
      showScreen("setup");
      vibrate(14);
    });

    // Init
    (async function init(){
      try{
        await loadJSONOrDie();
      }catch(e){
        $("#dbPill").style.borderColor = "rgba(138,12,29,.30)";
        $("#dbPill").style.background = "rgba(138,12,29,.10)";
        dbCount.textContent = "0";
        alert("No se pudo iniciar el mazo. Revis√° que el archivo est√© en la misma carpeta.");
      }
      loadSetupFromStorage();
      loadThemeFromStorage();
      updateCategorySummary();
      refreshChips();
    })();
  </script>
</body>
</html>
