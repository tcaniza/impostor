<!doctype html>
<html lang="es-AR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#590404" />
  <title>El impostor</title>
<link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"
  /><link rel="stylesheet" href="styles.css" />
  <link rel="icon" href="logo_blanco.svg" id="favicon" />
</head>

<body>
  <div class="app">
    <div class="topbar">
      <div class="brand">
        <img class="mascot animate__animated animate__pulse animate__infinite animate__slow" src="logo_blanco.svg" alt="Logo de El impostor" id="brandLogo" />
        <div>
          <h1>El impostor</h1>
        </div>
      </div>
      <div class="topbar-actions">
        <button class="theme-toggle" id="themeToggle" type="button" aria-pressed="false">Modo oscuro</button>
        <div class="pill" id="dbPill">Palabras: <strong id="dbCount">‚Ä¶</strong></div>
      </div>
    </div>


    <div class="steps animate__animated animate__slideInDown" id="steps" aria-label="Progreso de la partida">
      <div class="step active" data-step="setup"><span class="dot"></span><span class="txt">Config</span></div>
      <div class="step" data-step="pass"><span class="dot"></span><span class="txt">Pasar</span></div>
      <div class="step" data-step="reveal"><span class="dot"></span><span class="txt">Ver</span></div>
      <div class="step" data-step="play"><span class="dot"></span><span class="txt">Jugar</span></div>
      <div class="step" data-step="summary"><span class="dot"></span><span class="txt">Resumen</span></div>
    </div>

    <!-- SETUP -->
    <section class="card screen active" id="screenSetup" data-animate="animate__fadeInUp">
      <h2 class="title" data-animate="animate__backInDown">Configurar partida</h2>
      <p class="desc" data-animate="animate__fadeIn">
        Eleg√≠ impostores, carg√° nombres y empez√°. El impostor ve una pista, los dem√°s ven la palabra.
      </p>

      <label data-animate="animate__fadeIn">¬øCu√°ntos impostores?</label>
      <div class="seg" role="group" aria-label="Cantidad de impostores" data-animate="animate__zoomIn">
        <button type="button" class="segBtn" data-impostors="1" aria-pressed="true">1 impostor</button>
        <button type="button" class="segBtn" data-impostors="2" aria-pressed="false">2 impostores</button>
      </div>

      <label data-animate="animate__fadeIn">Nombres</label>
      <div class="namesGrid" id="namesGrid" aria-label="Lista de jugadores" data-animate="animate__fadeInUp">
        <input class="nameInput" type="text" inputmode="text" autocomplete="off" placeholder="Jugador 1" data-index="0" />
        <input class="nameInput" type="text" inputmode="text" autocomplete="off" placeholder="Jugador 2" data-index="1" />
        <input class="nameInput" type="text" inputmode="text" autocomplete="off" placeholder="Jugador 3" data-index="2" />
      </div>
      <p class="tiny hint" id="namesHint">Se agregan m√°s campos autom√°ticamente hasta 10 jugadores.</p>

      <div class="chipset" id="namesChips" aria-label="Lista de jugadores" data-animate="animate__fadeInUp"></div>

      <label data-animate="animate__fadeIn">Categor√≠as de palabras</label>
      <div class="metaRow" data-animate="animate__fadeInUp">
        <button class="btn secondary" id="btnCategories" type="button">Seleccionar categor√≠as</button>
        <div class="pill mini" id="categoryPill">Categor√≠as: <strong id="categoryCount">‚Äî</strong></div>
      </div>
      <p class="tiny" id="categorySummary" data-animate="animate__fadeIn">Todas las categor√≠as activas.</p>

      <div class="spacer"></div>

      <div class="metaRow" aria-label="Estado" data-animate="animate__fadeInUp">
        <div class="pill mini" id="savedPill">Nombres: <strong id="savedState">‚Äî</strong></div>
        <div class="pill mini">M√≠nimo: <strong id="minPlayers">‚Äî</strong></div>
      </div>

      <div class="footerRow" data-animate="animate__fadeInUp">
        <button class="btn" id="btnStart" type="button" disabled>Iniciar juego</button>
        <!-- <button class="btn secondary" id="btnClearNames" type="button">Borrar nombres</button> -->
      </div>

      <p class="tiny" data-animate="animate__fadeIn">
        Tip: cuando toc√°s <b>Estoy listo</b>, aparece tu palabra o tu pista. Mir√° r√°pido y pas√°.
      </p>
    </section>

    <!-- PASS -->
    <section class="card screen" id="screenPass" data-animate="animate__fadeInUp">
      <div style="display:flex; justify-content:space-between; gap:10px; align-items:center; position:relative; z-index:1;">
        <div class="pill">Jugador <strong id="passIdx">1</strong>/<strong id="passTotal">1</strong></div>
        <button class="btn secondary" id="btnAbort" type="button" style="width:auto; padding:10px 12px;">Volver</button>
      </div>

      <div class="center" style="position:relative; z-index:1;">
        <img class="passMascot animate__animated animate__pulse animate__infinite animate__slower" src="logo_blanco.svg" alt="Logo de El impostor" id="passLogo" data-animate="animate__zoomIn" />
        <div class="big" data-animate="animate__fadeInUp">Pas√° el celu a</div>
        <div class="secret" id="passName" data-animate="animate__bounceIn">‚Äî</div>
        <p class="desc" data-animate="animate__fadeIn">Cuando lo tengas, toc√° el bot√≥n para ver tu rol.</p>
        <div class="spacer"></div>
        <button class="btn" id="btnImReady" type="button" data-animate="animate__pulse">Estoy listo</button>
        <p class="tiny" data-animate="animate__fadeIn">Que nadie mire üòÑ</p>
      </div>
    </section>

    <!-- REVEAL -->
    <section class="card screen" id="screenReveal" data-animate="animate__fadeInUp">
      <div style="display:flex; justify-content:space-between; gap:10px; align-items:center; position:relative; z-index:1;">
        <div class="pill">Turno de <strong id="revealName">‚Äî</strong></div>
      </div>

      <div class="revealBox" data-animate="animate__fadeInUp">
        <div class="badge warn" id="roleBadge" data-animate="animate__rubberBand">Rol</div>

        <div id="secretWrap" aria-live="polite" data-animate="animate__zoomIn">
          <div class="secret" id="secretMain" data-animate="animate__zoomIn">‚Äî</div>
          <p class="secretSub" id="secretSub" data-animate="animate__fadeIn">‚Äî</p>
        </div>

        <p class="tiny" style="margin-top:10px;" data-animate="animate__fadeIn">
          Cuando termines, toc√° <b>Ocultar y pasar</b>.
        </p>

        <div class="footerRow" data-animate="animate__fadeInUp">
          <button class="btn secondary" id="btnHideNext" type="button" data-animate="animate__pulse">Ocultar y pasar</button>
        </div>
      </div>
    </section>

    <!-- PLAY -->
    <section class="card screen" id="screenPlay" data-animate="animate__fadeInUp">
      <h2 class="title" data-animate="animate__backInDown">¬°A jugar!</h2>
      <p class="desc" data-animate="animate__fadeIn">
        Ya todos vieron su rol. Ahora juegan y cuando quieran, finalizan la partida.
      </p>

      <div class="revealBox" data-animate="animate__fadeInUp">
        <div class="badge good" data-animate="animate__bounceIn">Partida en curso</div>
        <p class="desc" style="margin-top:4px;" data-animate="animate__fadeIn">
          Impostores: <b id="playImpostors">1</b> ¬∑ Jugadores: <b id="playPlayers">‚Äî</b>
        </p>

        <div class="footerRow" data-animate="animate__fadeInUp">
          <button class="btn danger" id="btnFinish" type="button" data-animate="animate__pulse">Finalizar partida</button>
          <button class="btn secondary" id="btnNew" type="button" data-animate="animate__pulse">Repartir de nuevo</button>
        </div>
      </div>
    </section>

    <!-- SUMMARY -->
    <section class="card screen" id="screenSummary" data-animate="animate__fadeInUp">
      <h2 class="title" data-animate="animate__backInDown">Resumen</h2>
      <p class="desc" data-animate="animate__fadeIn">Palabra real y qui√©n(es) fueron impostor(es).</p>

      <div class="revealBox" data-animate="animate__fadeInUp">
        <div class="secret" id="sumWord" data-animate="animate__zoomIn">‚Äî</div>
        <p class="secretSub" id="sumClue" data-animate="animate__fadeIn">‚Äî</p>

        <div class="spacer"></div>
        <div class="badge bad" data-animate="animate__jackInTheBox">Impostor(es)</div>
        <div id="sumImpostors" class="chipset" data-animate="animate__fadeInUp"></div>

        <div class="spacer"></div>
        <div class="badge good" data-animate="animate__jackInTheBox">No impostores</div>
        <div id="sumCrew" class="chipset" data-animate="animate__fadeInUp"></div>

        <div class="footerRow" data-animate="animate__fadeInUp">
          <button class="btn" id="btnBackSetup" type="button" data-animate="animate__pulse">Volver al inicio</button>
        </div>
      </div>
    </section>
  </div>

  <dialog id="categoryDialog" class="categoryDialog" aria-labelledby="categoryTitle">
    <form method="dialog" class="dialogCard" data-animate="animate__zoomIn">
      <div class="dialogHeader">
        <h3 id="categoryTitle">Categor√≠as de la ronda</h3>
        <button type="button" class="iconBtn" id="btnCloseCategories" aria-label="Cerrar">√ó</button>
      </div>
      <p class="desc">Eleg√≠ las categor√≠as con las que van a jugar para que todos entiendan la tem√°tica.</p>
      <div class="dialogActions">
        <button type="button" class="btn secondary small" id="btnCatAll">Seleccionar todas</button>
        <button type="button" class="btn secondary small" id="btnCatNone">Deseleccionar todas</button>
      </div>
      <div class="categoryList" id="categoryList"></div>
      <div class="footerRow">
        <button class="btn" id="btnSaveCategories" type="button">Guardar categor√≠as</button>
      </div>
    </form>
  </dialog>

<script>
  // Helpers
  const $ = (sel) => document.querySelector(sel);

  const screens = {
    setup: $("#screenSetup"),
    pass: $("#screenPass"),
    reveal: $("#screenReveal"),
    play: $("#screenPlay"),
    summary: $("#screenSummary"),
  };

  function updateSteps(activeKey){
    const stepsEl = $("#steps");
    if(!stepsEl) return;
    const order = ["setup","pass","reveal","play","summary"];
    const activeIdx = order.indexOf(activeKey);

    stepsEl.querySelectorAll(".step").forEach((el) => {
      const wasActive = el.classList.contains("active");
      const wasDone = el.classList.contains("done");
      const k = el.dataset.step;
      const idx = order.indexOf(k);
      el.classList.toggle("active", k === activeKey);
      el.classList.toggle("done", idx > -1 && activeIdx > -1 && idx < activeIdx);

      if(!wasActive && k === activeKey){
        const dot = el.querySelector(".dot") || el;
        playAnim(dot, "animate__heartBeat", { durationMs: 420 });
      }

      if(!wasDone && idx > -1 && activeIdx > -1 && idx < activeIdx){
        const dot = el.querySelector(".dot") || el;
        playAnim(dot, "animate__bounceIn", { durationMs: 420 });
      }
    });
  }

  // ===== Animaci√≥n robusta con animate.css =====
  function stripAnimateClasses(el){
    if(!el) return;
    for(const c of Array.from(el.classList)){
      if(c.startsWith("animate__") && c !== "animate__animated"){
        el.classList.remove(c);
      }
    }
  }

  function cleanupAnimateInline(el){
    if(!el) return;
    el.style.removeProperty("--animate-delay");
    el.style.removeProperty("--animate-duration");
  }

  function parseDelayToMs(delay){
    if(delay == null) return 0;
    if(typeof delay === "number") return delay;

    const s = String(delay).trim();
    if(!s) return 0;

    // soporta "0.2s" o "200ms"
    if(s.endsWith("ms")) return Math.max(0, parseFloat(s));
    if(s.endsWith("s")) return Math.max(0, Math.round(parseFloat(s) * 1000));

    const n = parseFloat(s);
    if(Number.isFinite(n)){
      // si te pasan "0.2" lo interpretamos como segundos (compat con tu c√≥digo viejo)
      return n <= 5 ? Math.round(n * 1000) : Math.round(n);
    }
    return 0;
  }

  function playAnim(el, anim, { delayMs = 0, durationMs = 520, keep = false } = {}){
    if(!el || !anim) return Promise.resolve();

    // Si no ten√≠a animate__animated antes, lo marcamos para poder quitarlo luego
    const hadAnimated = el.classList.contains("animate__animated");
    if(!hadAnimated) el.dataset.animOwned = "1";

    el.classList.add("animate__animated");
    el.style.setProperty("--animate-delay", `${delayMs}ms`);
    el.style.setProperty("--animate-duration", `${durationMs}ms`);

    // Importante: sacar animaciones previas (excepto animate__animated) y reflow
    stripAnimateClasses(el);
    void el.offsetWidth;

    el.classList.add(anim);

    return new Promise((resolve) => {
      const onEnd = () => {
        // En animaciones de salida conviene keep para evitar "snap" visual
        if(!keep){
          el.classList.remove(anim);
          cleanupAnimateInline(el);

          if(el.dataset.animOwned === "1"){
            el.classList.remove("animate__animated");
            delete el.dataset.animOwned;
          }
        }
        resolve();
      };
      el.addEventListener("animationend", onEnd, { once: true });
    });
  }

  // Wrapper compatible con tu c√≥digo viejo (mantiene la firma)
  function animateElement(el, animation, delay = null){
    const delayMs = parseDelayToMs(delay);
    // No await: dejamos que corra en background (como antes)
    playAnim(el, animation, { delayMs, durationMs: 520 });
  }

  function animateScreenElements(screenEl){
    if(!screenEl) return;
    const items = Array.from(screenEl.querySelectorAll("[data-animate]"));
    items.forEach((el, idx) => {
      const anim = el.dataset.animate;
      const delayMs = el.dataset.animateDelay
        ? parseDelayToMs(el.dataset.animateDelay)
        : Math.min(idx * 60, 420); // stagger suave

      // Duraci√≥n un poco m√°s corta en elementos chicos
      const durationMs = el.matches(".badge,.pill,.chip,.dot,.txt") ? 420 : 520;

      playAnim(el, anim, { delayMs, durationMs });
    });
  }

  function focusForScreen(key){
    const map = {
      setup: () => document.querySelector(".nameInput"),
      pass: () => $("#btnImReady"),
      reveal: () => $("#btnHideNext"),
      play: () => $("#btnFinish"),
      summary: () => $("#btnBackSetup"),
    };
    try{
      const el = map[key]?.();
      if(el) requestAnimationFrame(() => el.focus({ preventScroll: true }));
    }catch(e){}
  }

  let currentScreen = "setup";
  let _navBusy = false;

  async function showScreen(key){
    if(_navBusy) return;
    if(!screens[key]) return;
    if(currentScreen === key) return;

    _navBusy = true;
    const prevKey = currentScreen;
    const prevEl = screens[prevKey];
    const nextEl = screens[key];

    try{
      // Salida: mantenemos visible el anterior mientras anima
      if(prevEl && prevEl !== nextEl){
        prevEl.classList.add("leaving");
        prevEl.classList.add("active");

        await playAnim(prevEl, "animate__fadeOutUp", { durationMs: 260, keep: true });

        // Ocultamos y limpiamos
        prevEl.classList.remove("active");
        prevEl.classList.remove("leaving");

        stripAnimateClasses(prevEl);
        cleanupAnimateInline(prevEl);
        if(prevEl.dataset.animOwned === "1"){
          prevEl.classList.remove("animate__animated");
          delete prevEl.dataset.animOwned;
        }
      }

      // Entrada
      nextEl.classList.add("active");
      await playAnim(nextEl, "animate__fadeInUp", { durationMs: 320 });

      // Animaciones internas: dispararlas DESPU√âS de que el screen entr√≥
      requestAnimationFrame(() => animateScreenElements(nextEl));

      currentScreen = key;
      updateSteps(key);

      // Evitar jank: sin smooth durante animaciones
      window.scrollTo({ top: 0, behavior: "auto" });

      focusForScreen(key);
    } finally {
      _navBusy = false;
    }
  }

  function vibrate(ms=18){
    try{ if (navigator.vibrate) navigator.vibrate(ms); }catch(e){}
  }

  function shuffle(arr){
    const a = arr.slice();
    for(let i=a.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  function sampleOne(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

  // LocalStorage (nombres y configuraci√≥n)
  const LS = {
    names: "impostor_ar_names_v1",
    impostors: "impostor_ar_impostors_v1",
    theme: "impostor_ar_theme_v1",
    categories: "impostor_ar_categories_v1",
  };

  function storageGet(key){
    try{ return localStorage.getItem(key); }catch(e){ return null; }
  }

  function storageSet(key, val){
    try{ localStorage.setItem(key, String(val)); }catch(e){}
  }

  function storageRemove(key){
    try{ localStorage.removeItem(key); }catch(e){}
  }

  function storageGetJSON(key, fallback = null){
    const raw = storageGet(key);
    if(!raw) return fallback;
    try{ return JSON.parse(raw); }catch(e){ return fallback; }
  }

  function storageSetJSON(key, val){
    storageSet(key, JSON.stringify(val));
  }

  // State
  let wordsDB = [];
  let fullWordsDB = [];
  let categories = [];
  let selectedCategories = new Set();
  let draftCategories = new Set();
  let impostorsCount = 1;

  let players = [];
  let impostorIdx = [];
  let currentPlayer = 0;

  let round = { palabra: "", pista: "", categoria: "" };

  const categoryLabels = {
    objetos: "Objetos",
    personas: "Personas",
    naturaleza: "Naturaleza",
    animales: "Animales",
    tecnologia: "Tecnolog√≠a",
    lugares: "Lugares",
    comida: "Comida",
    acciones: "Acciones",
  };

  function getCategoryLabel(category){
    if(categoryLabels[category]) return categoryLabels[category];
    return category
      .replace(/_/g, " ")
      .replace(/\b\w/g, (letter) => letter.toUpperCase());
  }

  // Elements
  const dbCount = $("#dbCount");
  const themeToggle = $("#themeToggle");
  const brandLogo = $("#brandLogo");
  const passLogo = $("#passLogo");
  const favicon = $("#favicon");

  const segBtns = Array.from(document.querySelectorAll(".segBtn"));
  const namesGrid = $("#namesGrid");
  const namesChips = $("#namesChips");
  const btnStart = $("#btnStart");
  const btnClearNames = $("#btnClearNames");
  const minPlayersEl = $("#minPlayers");
  const savedStateEl = $("#savedState");
  const savedPill = $("#savedPill");
  const btnCategories = $("#btnCategories");
  const categoryCount = $("#categoryCount");
  const categoryPill = $("#categoryPill");
  const categorySummary = $("#categorySummary");
  const categoryDialog = $("#categoryDialog");
  const categoryList = $("#categoryList");
  const btnSaveCategories = $("#btnSaveCategories");
  const btnCatAll = $("#btnCatAll");
  const btnCatNone = $("#btnCatNone");
  const btnCloseCategories = $("#btnCloseCategories");

  const passIdx = $("#passIdx");
  const passTotal = $("#passTotal");
  const passName = $("#passName");
  const btnImReady = $("#btnImReady");
  const btnAbort = $("#btnAbort");

  const revealName = $("#revealName");
  const roleBadge = $("#roleBadge");
  const secretMain = $("#secretMain");
  const secretSub = $("#secretSub");
  const secretWrap = $("#secretWrap");
  const btnHideNext = $("#btnHideNext");

  const playImpostors = $("#playImpostors");
  const playPlayers = $("#playPlayers");
  const btnFinish = $("#btnFinish");
  const btnNew = $("#btnNew");

  const sumWord = $("#sumWord");
  const sumClue = $("#sumClue");
  const sumImpostors = $("#sumImpostors");
  const sumCrew = $("#sumCrew");
  const btnBackSetup = $("#btnBackSetup");

  function applyTheme(theme){
    const root = document.documentElement;
    const useDark = theme === "dark";
    root.dataset.theme = useDark ? "dark" : "light";
    const logoSrc = useDark ? "logo_negro.svg" : "logo_blanco.svg";
    if(brandLogo) brandLogo.src = logoSrc;
    if(passLogo) passLogo.src = logoSrc;
    if(favicon) favicon.href = logoSrc;
    if(themeToggle){
      themeToggle.textContent = useDark ? "Modo claro" : "Modo oscuro";
      themeToggle.setAttribute("aria-pressed", useDark ? "true" : "false");
    }
  }

  function loadThemeFromStorage(){
    const savedTheme = storageGet(LS.theme);
    const theme = savedTheme === "dark" ? "dark" : "light";
    applyTheme(theme);
  }

  // Load JSON (siempre en mismo directorio)
  async function loadJSONOrDie(){
    const res = await fetch("./impostor_500.json", { cache: "no-store" });
    if(!res.ok) throw new Error("No se pudo cargar el mazo.");
    const data = await res.json();
    validateDB(data);
    setDB(data);
  }

  function validateDB(data){
    if(!Array.isArray(data)) throw new Error("Mazo inv√°lido.");
    if(data.length < 50) throw new Error("Mazo inv√°lido.");
    const x = data[0];
    if(!x || typeof x !== "object") throw new Error("Mazo inv√°lido.");
    if(!("palabra" in x) || !("pista" in x) || !("categoria" in x)) throw new Error("Mazo inv√°lido.");
  }

  function setDB(data){
    fullWordsDB = data
      .filter(x => x && typeof x.palabra === "string" && typeof x.pista === "string" && typeof x.categoria === "string")
      .map(x => ({
        palabra: x.palabra.trim(),
        pista: x.pista.trim(),
        categoria: x.categoria.trim(),
      }))
      .filter(x => x.palabra.length && x.pista.length && x.categoria.length);

    categories = Array.from(new Set(fullWordsDB.map(x => x.categoria)))
      .sort((a, b) => getCategoryLabel(a).localeCompare(getCategoryLabel(b), "es"));

    loadCategoriesFromStorage();
    applyCategoryFilter();
  }

  // Players
  function parseNames(list){
    const raw = list.map((value) => value.trim()).filter(Boolean);
    const seen = new Set();
    const unique = [];
    for(const n of raw){
      const key = n.toLowerCase();
      if(!seen.has(key)){
        seen.add(key);
        unique.push(n);
      }
    }
    return unique;
  }

  function getNameValues(){
    if(!namesGrid) return [];
    return Array.from(namesGrid.querySelectorAll(".nameInput")).map((input) => input.value);
  }

  function normalizedNames(){
    return parseNames(getNameValues()).join("\n");
  }

  function ensureNameInputs(){
    if(!namesGrid) return;
    const inputs = Array.from(namesGrid.querySelectorAll(".nameInput"));
    const maxPlayers = 10;
    const filledCount = inputs.filter((input) => input.value.trim().length > 0).length;
    const desiredCount = Math.min(maxPlayers, Math.max(3, Math.min(maxPlayers, filledCount + 1)));

    if(inputs.length < desiredCount){
      for(let i = inputs.length; i < desiredCount; i++){
        const input = document.createElement("input");
        input.className = "nameInput";
        input.type = "text";
        input.inputMode = "text";
        input.autocomplete = "off";
        input.placeholder = `Jugador ${i + 1}`;
        input.dataset.index = String(i);
        input.addEventListener("input", handleNamesInput);
        input.addEventListener("blur", handleNamesBlur);
        namesGrid.appendChild(input);
      }
    }

    if(inputs.length > desiredCount){
      for(let i = inputs.length - 1; i >= desiredCount; i--){
        namesGrid.removeChild(inputs[i]);
      }
    }
  }

  function renderInputsFromSaved(text){
    if(!namesGrid) return;
    const values = text.split(/\r?\n/).map((value) => value.trim()).filter(Boolean);
    const maxPlayers = 10;
    const count = Math.min(maxPlayers, Math.max(3, values.length + 1));
    namesGrid.innerHTML = "";
    for(let i = 0; i < count; i++){
      const input = document.createElement("input");
      input.className = "nameInput";
      input.type = "text";
      input.inputMode = "text";
      input.autocomplete = "off";
      input.placeholder = `Jugador ${i + 1}`;
      input.dataset.index = String(i);
      input.value = values[i] || "";
      input.addEventListener("input", handleNamesInput);
      input.addEventListener("blur", handleNamesBlur);
      namesGrid.appendChild(input);
    }
  }

  function updateSavedUI(){
    const saved = storageGet(LS.names) || "";
    const current = normalizedNames();
    let label = "No guardados";
    if(saved){
      label = (saved === current) ? "Guardados" : "Editados";
    }
    if(savedStateEl) savedStateEl.textContent = label;
    if(savedPill) savedPill.classList.toggle("dirty", saved && saved !== current);
  }

  function saveSetupToStorage(){
    storageSet(LS.impostors, impostorsCount);
    storageSet(LS.names, normalizedNames());
    updateSavedUI();
  }

  function loadSetupFromStorage(){
    const savedNames = storageGet(LS.names);
    if(savedNames && typeof savedNames === "string"){
      renderInputsFromSaved(savedNames);
    }else{
      renderInputsFromSaved("");
    }
    const savedImp = Number(storageGet(LS.impostors));
    if(savedImp === 1 || savedImp === 2){
      impostorsCount = savedImp;
    }
    segBtns.forEach(b => {
      const n = Number(b.dataset.impostors);
      b.setAttribute("aria-pressed", n === impostorsCount ? "true" : "false");
    });
    updateSavedUI();
  }

  function loadCategoriesFromStorage(){
    const saved = storageGetJSON(LS.categories, []);
    if(Array.isArray(saved)){
      selectedCategories = new Set(saved.filter((cat) => categories.includes(cat)));
    }
    if(selectedCategories.size === 0){
      selectedCategories = new Set(categories);
    }
  }

  function saveCategoriesToStorage(){
    storageSetJSON(LS.categories, Array.from(selectedCategories));
  }

  function updateCategorySummary(){
    const total = categories.length;
    const selected = selectedCategories.size;
    if(categoryCount) categoryCount.textContent = `${selected}/${total}`;
    if(categoryPill) categoryPill.classList.toggle("dirty", selected === 0);
    if(!categorySummary) return;

    if(selected === 0){
      categorySummary.textContent = "Seleccion√° al menos una categor√≠a.";
      return;
    }
    if(selected === total){
      categorySummary.textContent = "Todas las categor√≠as activas.";
      return;
    }

    const list = categories
      .filter((category) => selectedCategories.has(category))
      .map(getCategoryLabel)
      .slice(0, 3);

    const extra = selected - list.length;
    const suffix = extra > 0 ? ` y ${extra} m√°s` : "";
    categorySummary.textContent = `Activas: ${list.join(", ")}${suffix}.`;
  }

  function applyCategoryFilter(){
    wordsDB = fullWordsDB.filter((w) => selectedCategories.has(w.categoria));
    dbCount.textContent = wordsDB.length.toString();
    $("#dbPill").style.borderColor = "rgba(27,122,100,.30)";
    $("#dbPill").style.background = "rgba(27,122,100,.10)";
    updateCategorySummary();
  }

  function renderCategoryDialog(){
    if(!categoryList) return;
    categoryList.innerHTML = "";
    categories.forEach((cat, idx) => {
      const row = document.createElement("label");
      row.className = "categoryItem";
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.value = cat;
      checkbox.checked = draftCategories.has(cat);
      checkbox.addEventListener("change", () => {
        if(checkbox.checked) draftCategories.add(cat);
        else draftCategories.delete(cat);
      });
      const span = document.createElement("span");
      span.textContent = getCategoryLabel(cat);
      row.appendChild(checkbox);
      row.appendChild(span);
      categoryList.appendChild(row);
      playAnim(row, "animate__fadeInUp", { delayMs: Math.min(idx * 30, 180), durationMs: 320 });
    });
  }

  function openCategoryDialog(){
    draftCategories = new Set(selectedCategories);
    renderCategoryDialog();
    if(categoryDialog?.showModal){
      categoryDialog.showModal();
    }else if(categoryDialog){
      categoryDialog.setAttribute("open", "true");
    }

    // Animaci√≥n de entrada del dialog (si tiene data-animate)
    const card = categoryDialog?.querySelector("[data-animate]");
    if(card){
      animateElement(card, card.dataset.animate);
    }
  }

  async function closeCategoryDialog(){
    const card = categoryDialog?.querySelector("[data-animate]");
    if(card){
      await playAnim(card, "animate__zoomOut", { durationMs: 220, keep: true });
      stripAnimateClasses(card);
      cleanupAnimateInline(card);
    }
    if(categoryDialog?.close){
      categoryDialog.close();
    }else if(categoryDialog){
      categoryDialog.removeAttribute("open");
    }
  }

  function toggleAllCategories(checked){
    draftCategories = checked ? new Set(categories) : new Set();
    renderCategoryDialog();
  }

  function refreshChips(){
    ensureNameInputs();
    players = parseNames(getNameValues());
    namesChips.innerHTML = "";

    players.forEach((name, idx) => {
      const chip = document.createElement("div");
      chip.className = "chip";
      chip.innerHTML = `<span>${name}</span>`;
      const x = document.createElement("button");
      x.type = "button";
      x.textContent = "√ó";
      x.title = "Quitar";
      x.addEventListener("click", async () => {
        if(chip.dataset.animating) return;
        chip.dataset.animating = "1";
        vibrate(12);
        await playAnim(chip, "animate__fadeOutRight", { durationMs: 260, keep: true });
        const arr = parseNames(getNameValues());
        arr.splice(idx, 1);
        renderInputsFromSaved(arr.join("\n"));
        ensureNameInputs();
        refreshChips();
      });
      chip.appendChild(x);
      namesChips.appendChild(chip);
      playAnim(chip, "animate__fadeInUp", { delayMs: Math.min(idx * 40, 200), durationMs: 360 });
    });

    const minPlayers = Math.max(3, impostorsCount + 2);
    btnStart.disabled = !(wordsDB.length > 0 && selectedCategories.size > 0 && players.length >= minPlayers);
    if(minPlayersEl) minPlayersEl.textContent = String(minPlayers);
    updateSavedUI();
  }

  // Round setup
  function setupNewRound(){
    if(!wordsDB.length) return;

    const pick = sampleOne(wordsDB);
    round.palabra = pick.palabra;
    round.pista = pick.pista;
    round.categoria = pick.categoria;

    const idx = shuffle([...players.keys()]);
    impostorIdx = idx.slice(0, impostorsCount).sort((a,b)=>a-b);

    currentPlayer = 0;

    passTotal.textContent = players.length;
    updatePass();
  }

  function updatePass(){
    passIdx.textContent = (currentPlayer + 1);
    passName.textContent = players[currentPlayer] ?? "‚Äî";
    if(currentScreen === "pass"){
      playAnim(passName, "animate__flipInX", { durationMs: 420 });
    }
  }

  function isImpostor(i){ return impostorIdx.includes(i); }

  // Reveal (directo: palabra o pista)
  function openReveal(){
    const name = players[currentPlayer];
    revealName.textContent = name;

    const imp = isImpostor(currentPlayer);

    if(imp){
      roleBadge.className = "badge bad";
      roleBadge.textContent = "SOS IMPOSTOR üòà";
      secretMain.textContent = round.pista;
      secretSub.textContent = `Categor√≠a: ${getCategoryLabel(round.categoria)} ¬∑ ${round.palabra.length} letras. Disimul√° y trat√° de adivinar la palabra.`;
    }else{
      roleBadge.className = "badge good";
      roleBadge.textContent = "NO SOS IMPOSTOR ‚úÖ";
      secretMain.textContent = round.palabra;
      secretSub.textContent = "Guardate la palabra y disimul√°.";
    }

    if(secretWrap){
      animateElement(secretWrap, "animate__zoomIn");
    }
    vibrate(14);
    showScreen("reveal");
  }

  function nextPlayerOrPlay(){
    currentPlayer++;
    if(currentPlayer >= players.length){
      playImpostors.textContent = String(impostorsCount);
      playPlayers.textContent = String(players.length);
      vibrate(20);
      showScreen("play");
    }else{
      updatePass();
      showScreen("pass");
    }
  }

  // Summary
  function renderSummary(){
    sumWord.textContent = round.palabra;
    sumClue.textContent = `Pista: ${round.pista} ¬∑ Categor√≠a: ${getCategoryLabel(round.categoria)}`;

    sumImpostors.innerHTML = "";
    sumCrew.innerHTML = "";

    const impSet = new Set(impostorIdx);
    players.forEach((p, i) => {
      const chip = document.createElement("div");
      chip.className = "chip";
      chip.innerHTML = `<span>${p}</span>`;
      if(impSet.has(i)){
        sumImpostors.appendChild(chip);
        playAnim(chip, "animate__bounceInDown", { delayMs: Math.min(i * 40, 200), durationMs: 360 });
      }else{
        sumCrew.appendChild(chip);
        playAnim(chip, "animate__fadeInUp", { delayMs: Math.min(i * 40, 200), durationMs: 360 });
      }
    });
  }

  // Events
  segBtns.forEach(btn => {
    btn.addEventListener("click", () => {
      impostorsCount = Number(btn.dataset.impostors);
      segBtns.forEach(b => b.setAttribute("aria-pressed", b === btn ? "true" : "false"));
      refreshChips();
      storageSet(LS.impostors, impostorsCount);
      updateSavedUI();
      vibrate(12);
    });
  });

  function handleNamesInput(){
    ensureNameInputs();
    refreshChips();
  }

  function handleNamesBlur(){
    ensureNameInputs();
    refreshChips();
  }

  if(namesGrid){
    namesGrid.addEventListener("input", (event) => {
      if(event.target && event.target.classList.contains("nameInput")){
        handleNamesInput();
      }
    });
    namesGrid.addEventListener("blur", (event) => {
      if(event.target && event.target.classList.contains("nameInput")){
        handleNamesBlur();
      }
    }, true);
  }

  if(btnCategories){
    btnCategories.addEventListener("click", openCategoryDialog);
  }

  if(btnCloseCategories){
    btnCloseCategories.addEventListener("click", () => {
      closeCategoryDialog();
      vibrate(10);
    });
  }

  if(btnCatAll){
    btnCatAll.addEventListener("click", () => {
      toggleAllCategories(true);
      vibrate(10);
    });
  }

  if(btnCatNone){
    btnCatNone.addEventListener("click", () => {
      toggleAllCategories(false);
      vibrate(10);
    });
  }

  if(btnSaveCategories){
    btnSaveCategories.addEventListener("click", () => {
      selectedCategories = new Set(draftCategories);
      saveCategoriesToStorage();
      applyCategoryFilter();
      refreshChips();
      closeCategoryDialog();
      vibrate(12);
    });
  }

  if(themeToggle){
    themeToggle.addEventListener("click", () => {
      const nextTheme = document.documentElement.dataset.theme === "dark" ? "light" : "dark";
      applyTheme(nextTheme);
      storageSet(LS.theme, nextTheme);
      vibrate(12);
    });
  }

  if(btnClearNames) btnClearNames.addEventListener("click", () => {
    const hasSaved = !!(storageGet(LS.names) || "").trim();
    const hasCurrent = getNameValues().some((value) => value.trim().length > 0);
    if(!hasSaved && !hasCurrent){
      vibrate(10);
      return;
    }
    const ok = confirm("¬øBorrar los nombres guardados y limpiar la lista?");
    if(!ok) return;

    storageRemove(LS.names);
    renderInputsFromSaved("");
    refreshChips();
    vibrate(18);
  });

  btnStart.addEventListener("click", () => {
    refreshChips();
    saveSetupToStorage();
    setupNewRound();
    showScreen("pass");
  });

  btnAbort.addEventListener("click", () => {
    showScreen("setup");
    vibrate(16);
  });

  btnImReady.addEventListener("click", openReveal);
  btnHideNext.addEventListener("click", nextPlayerOrPlay);

  // Finalizar partida sin confirmaci√≥n
  btnFinish.addEventListener("click", () => {
    renderSummary();
    showScreen("summary");
    vibrate(24);
  });

  btnNew.addEventListener("click", () => {
    refreshChips();
    if(btnStart.disabled){
      showScreen("setup");
      vibrate(12);
      return;
    }
    setupNewRound();
    showScreen("pass");
    vibrate(16);
  });

  btnBackSetup.addEventListener("click", () => {
    refreshChips();
    showScreen("setup");
    vibrate(14);
  });

  // Init
  (async function init(){
    try{
      await loadJSONOrDie();
    }catch(e){
      $("#dbPill").style.borderColor = "rgba(138,12,29,.30)";
      $("#dbPill").style.background = "rgba(138,12,29,.10)";
      dbCount.textContent = "0";
      alert("No se pudo iniciar el mazo. Revis√° que el archivo est√© en la misma carpeta.");
    }
    loadSetupFromStorage();
    loadThemeFromStorage();
    updateCategorySummary();
    refreshChips();
  })();
</script>
</body>
</html>
